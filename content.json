{"meta":{"title":"Agile","subtitle":null,"description":null,"author":"Sean Yin","url":"http://seanyinx.github.io"},"pages":[{"title":"About","date":"2016-12-18T03:20:49.000Z","updated":"2016-12-22T13:48:12.187Z","comments":true,"path":"About/index.html","permalink":"http://seanyinx.github.io/About/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-12-18T03:34:19.000Z","updated":"2016-12-22T13:48:12.194Z","comments":true,"path":"Categories/index.html","permalink":"http://seanyinx.github.io/Categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Stats Calculator with TDD Part 2","slug":"Stats-Calculator-with-TDD-Part-2","date":"2016-12-31T08:27:13.000Z","updated":"2016-12-31T12:20:59.108Z","comments":true,"path":"2016/12/31/Stats-Calculator-with-TDD-Part-2/","link":"","permalink":"http://seanyinx.github.io/2016/12/31/Stats-Calculator-with-TDD-Part-2/","excerpt":"We implemented finding minimum value from a sequence of integers. Finding maximum and average is very straightforward and similar to what we have done in my previous post. So I will just put the code here directly to keep us from being bored.","text":"We implemented finding minimum value from a sequence of integers. Finding maximum and average is very straightforward and similar to what we have done in my previous post. So I will just put the code here directly to keep us from being bored. Test CasesIf you try with the sample integer sequence in my previous post, you may find that the calculated average is different from the expected one. I believe it’s a mistake in the original Kata.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class StatsCalculatorTest &#123; private StatsCalculator statsCalculator = new StatsCalculator(); @Test public void minOfSomeElementsReturnsTheMinimum() &#123; int min = statsCalculator.minOf(6, 9, 15, -2, 92, 11); assertThat(min, is(-2)); &#125; @Test public void minOfBlowsUpWhenNoElementProvided() &#123; try &#123; statsCalculator.minOf(); Assert.fail(IllegalArgumentException.class.getName() + \" expected\"); &#125; catch (IllegalArgumentException e) &#123; assertThat(e.getMessage(), is(\"No element provided\")); &#125; &#125; @Test public void maxOfSomeElementsReturnsTheMinimum() &#123; int max = statsCalculator.maxOf(6, 9, 15, -2, 92, 11); assertThat(max, is(92)); &#125; @Test public void maxOfBlowsUpWhenNoElementProvided() &#123; try &#123; statsCalculator.maxOf(); Assert.fail(IllegalArgumentException.class.getName() + \" expected\"); &#125; catch (IllegalArgumentException e) &#123; assertThat(e.getMessage(), is(\"No element provided\")); &#125; &#125; @Test public void averageOfSomeElementsReturnsTheMinimum() &#123; double average = statsCalculator.averageOf(6, 9, 15, -2, 92, 11); assertThat(average, closeTo(21.833333, 0.00001)); &#125; @Test public void averageOfBlowsUpWhenNoElementProvided() &#123; try &#123; statsCalculator.averageOf(); Assert.fail(IllegalArgumentException.class.getName() + \" expected\"); &#125; catch (IllegalArgumentException e) &#123; assertThat(e.getMessage(), is(\"No element provided\")); &#125; &#125;&#125; Product CodeThe production code for finding minimum, maximum, and average values looks like the follows.1234567891011121314151617181920212223242526272829303132333435public class StatsCalculator &#123; public int minOf(int... elements) &#123; if (elements.length == 0) &#123; throw new IllegalArgumentException(\"No element provided\"); &#125; int min = Integer.MAX_VALUE; for (int element : elements) &#123; min = Math.min(element, min); &#125; return min; &#125; public int maxOf(int... elements) &#123; if (elements.length == 0) &#123; throw new IllegalArgumentException(\"No element provided\"); &#125; int max = Integer.MIN_VALUE; for (int element : elements) &#123; max = Math.max(element, max); &#125; return max; &#125; public double averageOf(int... elements) &#123; if (elements.length == 0) &#123; throw new IllegalArgumentException(\"No element provided\"); &#125; int sum = 0; for (int element : elements) &#123; sum = element + sum; &#125; return ((double) sum) / elements.length; &#125;&#125; Are we done? There are quite a few duplicate code in the implementation above, such as the exception handling and looping of elements. RefactoringIt seems the only differences among the three methods are the initial min/max/sum value and operation on each element. We can extract the duplicate code to a common method, if we can pass those two as parameters. The only way to pass operations by parameter is to encapsulate the operations in objects and pass the objects as a parameter. In order for a single method to accept different types of operations, the objects containing the operations have to implement a common interface. 1. Extracting operationsWe have first extract min/max/average operations into objects. Extracting min operation Extracting max operation Extracting average operation 2.Extracting common interface 3. Extracting duplicate code to a methodWith operations extracted to objects implementing the same interface, we are ready to extract duplicate code to a common method and pass both initial value and operation of min/max/average to the method by parameter. 4. Code tidy up The Final CodeWe have finished refactoring our code and we shall run the test cases again (multiple times during the refactoring as well) to make sure everything is fine. Operation Interface 123public interface Command &#123; int invoke(int element, int min);&#125; Stats Calculator 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class StatsCalculator &#123; private final Command minCommand = new MinCommand(); private final Command maxCommand = new MaxCommand(); private final Command averageCommand = new AverageCommand(); public int minOf(int... elements) &#123; return aggregate(Integer.MAX_VALUE, minCommand, elements); &#125; public int maxOf(int... elements) &#123; return aggregate(Integer.MIN_VALUE, maxCommand, elements); &#125; public double averageOf(int... elements) &#123; int sum = aggregate(0, averageCommand, elements); return ((double) sum) / elements.length; &#125; private int aggregate(int value, Command command, int[] elements) &#123; if (elements.length == 0) &#123; throw new IllegalArgumentException(\"No element provided\"); &#125; int result = value; for (int element : elements) &#123; result = command.invoke(element, result); &#125; return result; &#125; private static class MinCommand implements Command &#123; @Override public int invoke(int element, int min) &#123; return Math.min(element, min); &#125; &#125; private static class MaxCommand implements Command &#123; public int invoke(int element, int max) &#123; return Math.max(element, max); &#125; &#125; private static class AverageCommand implements Command &#123; public int invoke(int element, int sum) &#123; return element + sum; &#125; &#125;&#125; SummaryWe have eliminated duplicate code and made our production code much easier to read. Moreover, if there’s a new requirement asking to perform more calculations, such as variance of elements, we are able to achieve that easily by implementing another subclass of Command interface. If you look at our test cases, they are concrete and quite easy to understand. I am pretty sure we achieved 100% test coverage too. To me, another benefit of TDD is fun. I am achieving all the benefits mentioned in my previous post while having fun! It will be totally different but terrible experience to write test cases after completing production code. If you don’t believe me, try it yourself.","categories":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.github.io/categories/TDD/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.github.io/tags/TDD/"},{"name":"XP","slug":"XP","permalink":"http://seanyinx.github.io/tags/XP/"},{"name":"Testing","slug":"Testing","permalink":"http://seanyinx.github.io/tags/Testing/"}]},{"title":"Stats Calculator with TDD Part 1","slug":"Stats-Calculator-with-TDD-Part-1","date":"2016-12-19T15:19:42.000Z","updated":"2016-12-31T12:20:59.107Z","comments":true,"path":"2016/12/19/Stats-Calculator-with-TDD-Part-1/","link":"","permalink":"http://seanyinx.github.io/2016/12/19/Stats-Calculator-with-TDD-Part-1/","excerpt":"I am going to demonstrate how to complete Stats Calculator with Test Driven Development.Before we start, let me introduce you the three laws of TDD by Robert Martin. You can’t write any production code until you have first written a failing unit test. You can’t write more of a unit test than is sufficient to fail, and not compiling is failing. You can’t write more production code than is sufficient to pass the currently failing unit test. It reads unnatural at first, but I hope you will understand better after reading this post.","text":"I am going to demonstrate how to complete Stats Calculator with Test Driven Development.Before we start, let me introduce you the three laws of TDD by Robert Martin. You can’t write any production code until you have first written a failing unit test. You can’t write more of a unit test than is sufficient to fail, and not compiling is failing. You can’t write more production code than is sufficient to pass the currently failing unit test. It reads unnatural at first, but I hope you will understand better after reading this post. Stats CalculatorThe details of this kata can be found in the link: Calc Stats.12345678910111213141516Calc Stats:Your task is to process a sequence of integer numbersto determine the following statistics:o) minimum valueo) maximum valueo) number of elements in the sequenceo) average valueFor example: 6, 9, 15, -2, 92, 11o) minimum value = -2o) maximum value = 92o) number of elements in the sequence = 6o) average value = 18.166666 Let’s start with finding the minimum value. 1. Write the 1st Failing TestIt’s recommended to write the 1st failing test as simple as possible and only partially cover the requirement, since we have no production code to start with. In our case, the simplest case is to find the minimum from a single element. Make sure you run the failing test case before proceeding with production code, in order to make sure it is effective. 2. Make the Test PassAt this moment, our goal is just to make the 1st test case pass. We may have a rough design concept in mind, but we do not just put the entire design to code, since we are not sure if it’s a good one. One of the most important practices in Agile is Simple Design. It’s better to evolve our code gradually by writing the minimum code that make the test cases pass. Let the final solution emerge. 3. Write a More General Failing TestNow we can expand our tests to cover more general cases. 4. Satisfy The Requirement 5. Write a Boundary Test CaseThe happy path works fine now, but we have to take care of the boundary case, an empty sequence of integers. There’s nothing much we can do except throwing an exception to tell the caller that something is wrong in this case. By the way, it’s a good practice to make sure the exception message is meaningful too, so that the issue can be easily identified in integration tests or logs in production by our support. 6. Implement the Boundary Case SummaryNow we have seen how we can use TDD to not only fulfill the requirement, but also evolve our solution to a good design. A very important lesson here is to start with the simplest test case possible, and gradually improve our code to a better design. It’s very easy to get stuck trying to come up with a perfect solution in the first place. We only completed finding the minimum of a sequence of integers today. Next, we will proceed with the rest of the requirements.","categories":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.github.io/categories/TDD/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.github.io/tags/TDD/"},{"name":"XP","slug":"XP","permalink":"http://seanyinx.github.io/tags/XP/"},{"name":"Testing","slug":"Testing","permalink":"http://seanyinx.github.io/tags/Testing/"}]},{"title":"Test Driven Development Introduction","slug":"Test-Driven-Development-Introduction","date":"2016-12-18T03:29:15.000Z","updated":"2016-12-31T12:20:59.118Z","comments":true,"path":"2016/12/18/Test-Driven-Development-Introduction/","link":"","permalink":"http://seanyinx.github.io/2016/12/18/Test-Driven-Development-Introduction/","excerpt":"Test Driven Development (TDD) is one of the eXtreme Programming (XP) practices developed by Kent Beck.It promotes repetitions of short coding cycles, to evolve the solutions with new requirements.","text":"Test Driven Development (TDD) is one of the eXtreme Programming (XP) practices developed by Kent Beck.It promotes repetitions of short coding cycles, to evolve the solutions with new requirements. The Coding Cycle of TDDTDD has a “mantra” with 3 steps, red/green/refactor: Write a simplest failing test case (hence red), before writing any production code. Write minimal production code possible to pass the failing test case (green) Refactor test case or production code The Benefit of TDDBetter designAs we know, tightly coupled code are hard to test. Since we always write tests before any production code, our code are always testable,meaning it is hard to write tightly coupled code with TDD. Much less code debuggingWe are working in short cycles of red/green/refactor with TDD. There won’t be much code written after the previous time our tests passed.That limits the scope of the bug we introduced and makes it very easy to spot. No fear to break codeTDD tends to produce code with very high test coverage (90%+ is very easy to achieve), since tests are always written first.It’s much less likely to break the code accidentally with such high code coverage. Continuous code improvement with refactoringTests are vital to refactoring. We are more likely to improve our code quality with refactoring, because the fear to break code is eliminated with tests.Or, nobody will touch bad code. We are afraid that the bad code will be ours, if we break it. Test case as documentationIf written well, test cases are the best documentation, because they are always up to date and describe the exact scenarios on how to use the production code. How To Start?TDD is an easy-to-learn but hard-to-master skill. The best way to improve our skill on TDD is through practices.There are many exercises called Katas, which can help accelerate our learning process.I will use one of the simplest Kata, Calc Stats to demonstrate how to get started with TDD in my next post.","categories":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.github.io/categories/TDD/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.github.io/tags/TDD/"},{"name":"XP","slug":"XP","permalink":"http://seanyinx.github.io/tags/XP/"},{"name":"Testing","slug":"Testing","permalink":"http://seanyinx.github.io/tags/Testing/"}]},{"title":"Hello World","slug":"Hello-World","date":"2016-12-18T03:26:00.000Z","updated":"2016-12-22T13:48:12.197Z","comments":true,"path":"2016/12/18/Hello-World/","link":"","permalink":"http://seanyinx.github.io/2016/12/18/Hello-World/","excerpt":"","text":"","categories":[],"tags":[]}]}