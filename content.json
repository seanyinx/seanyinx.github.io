{"meta":{"title":"Agile","subtitle":null,"description":null,"author":"Sean Yin","url":"http://seanyinx.coding.me"},"pages":[{"title":"Categories","date":"2016-12-18T03:34:19.000Z","updated":"2016-12-22T13:48:12.194Z","comments":true,"path":"Categories/index.html","permalink":"http://seanyinx.coding.me/Categories/index.html","excerpt":"","text":""},{"title":"About","date":"2016-12-18T03:20:49.000Z","updated":"2016-12-22T13:48:12.187Z","comments":true,"path":"About/index.html","permalink":"http://seanyinx.coding.me/About/index.html","excerpt":"","text":""}],"posts":[{"title":"Stats Calculator with TDD Part 2","slug":"Stats-Calculator-with-TDD-Part-2","date":"2016-12-31T08:27:13.000Z","updated":"2016-12-31T12:15:44.303Z","comments":true,"path":"2016/12/31/Stats-Calculator-with-TDD-Part-2/","link":"","permalink":"http://seanyinx.coding.me/2016/12/31/Stats-Calculator-with-TDD-Part-2/","excerpt":"在上一篇我们实现了从数列中查找最小值，而最大值和平均值的查找跟最小查找非常相似，所以这里直接给出已完成的测试和生产代码。","text":"在上一篇我们实现了从数列中查找最小值，而最大值和平均值的查找跟最小查找非常相似，所以这里直接给出已完成的测试和生产代码。 测试用例如果尝试使用原Kata中的样例数据，会发现平均值的期望结果和实际结果不符，因为原Kata的期望结果有误。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class StatsCalculatorTest &#123; private StatsCalculator statsCalculator = new StatsCalculator(); @Test public void minOfSomeElementsReturnsTheMinimum() &#123; int min = statsCalculator.minOf(6, 9, 15, -2, 92, 11); assertThat(min, is(-2)); &#125; @Test public void minOfBlowsUpWhenNoElementProvided() &#123; try &#123; statsCalculator.minOf(); Assert.fail(IllegalArgumentException.class.getName() + \" expected\"); &#125; catch (IllegalArgumentException e) &#123; assertThat(e.getMessage(), is(\"No element provided\")); &#125; &#125; @Test public void maxOfSomeElementsReturnsTheMinimum() &#123; int max = statsCalculator.maxOf(6, 9, 15, -2, 92, 11); assertThat(max, is(92)); &#125; @Test public void maxOfBlowsUpWhenNoElementProvided() &#123; try &#123; statsCalculator.maxOf(); Assert.fail(IllegalArgumentException.class.getName() + \" expected\"); &#125; catch (IllegalArgumentException e) &#123; assertThat(e.getMessage(), is(\"No element provided\")); &#125; &#125; @Test public void averageOfSomeElementsReturnsTheMinimum() &#123; double average = statsCalculator.averageOf(6, 9, 15, -2, 92, 11); assertThat(average, closeTo(21.833333, 0.00001)); &#125; @Test public void averageOfBlowsUpWhenNoElementProvided() &#123; try &#123; statsCalculator.averageOf(); Assert.fail(IllegalArgumentException.class.getName() + \" expected\"); &#125; catch (IllegalArgumentException e) &#123; assertThat(e.getMessage(), is(\"No element provided\")); &#125; &#125;&#125; 生产代码查找最小值、最大值、平均值的生产代码如下。1234567891011121314151617181920212223242526272829303132333435public class StatsCalculator &#123; public int minOf(int... elements) &#123; if (elements.length == 0) &#123; throw new IllegalArgumentException(\"No element provided\"); &#125; int min = Integer.MAX_VALUE; for (int element : elements) &#123; min = Math.min(element, min); &#125; return min; &#125; public int maxOf(int... elements) &#123; if (elements.length == 0) &#123; throw new IllegalArgumentException(\"No element provided\"); &#125; int max = Integer.MIN_VALUE; for (int element : elements) &#123; max = Math.max(element, max); &#125; return max; &#125; public double averageOf(int... elements) &#123; if (elements.length == 0) &#123; throw new IllegalArgumentException(\"No element provided\"); &#125; int sum = 0; for (int element : elements) &#123; sum = element + sum; &#125; return ((double) sum) / elements.length; &#125;&#125; 这样算是完成了吗？如果比较三个方法的代码，会发现其中有很多重复，比如异常处理和遍历所有元素。 重构生产代码中三个方法的区别，只有min/max/sum初始值和遍历中对数列中每个元素的处理。如果我们能把初始值和处理逻辑作为参数,那我们就能把重复代码抽取为一个共用的方法。 把处理逻辑作为参数的唯一办法就是把他们包在各自的对象中，这些对象需要实现同一个接口。 1. 抽取处理逻辑 抽取最小值处理逻辑 抽取最大值处理逻辑 抽取平均值处理逻辑 2.抽取共同接口 3. 讲重复代码抽取到方法中 4. 整理代码 完成的代码在重构过程中及完成重构之后，我们应运行测试用例以保证原来的代码行为没被破坏。 处理逻辑接口 123public interface Command &#123; int invoke(int element, int min);&#125; Stats Calculator 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class StatsCalculator &#123; private final Command minCommand = new MinCommand(); private final Command maxCommand = new MaxCommand(); private final Command averageCommand = new AverageCommand(); public int minOf(int... elements) &#123; return aggregate(Integer.MAX_VALUE, minCommand, elements); &#125; public int maxOf(int... elements) &#123; return aggregate(Integer.MIN_VALUE, maxCommand, elements); &#125; public double averageOf(int... elements) &#123; int sum = aggregate(0, averageCommand, elements); return ((double) sum) / elements.length; &#125; private int aggregate(int value, Command command, int[] elements) &#123; if (elements.length == 0) &#123; throw new IllegalArgumentException(\"No element provided\"); &#125; int result = value; for (int element : elements) &#123; result = command.invoke(element, result); &#125; return result; &#125; private static class MinCommand implements Command &#123; @Override public int invoke(int element, int min) &#123; return Math.min(element, min); &#125; &#125; private static class MaxCommand implements Command &#123; public int invoke(int element, int max) &#123; return Math.max(element, max); &#125; &#125; private static class AverageCommand implements Command &#123; public int invoke(int element, int sum) &#123; return element + sum; &#125; &#125;&#125; 总结我们去掉重复代码的同时，生产代码不但变得更易读了，而且如果将来需要进行扩展，如计算方差，也只需实现另一个Command的子类。 另外，我们的测试用例既详细又容易理解，而且测试覆盖率达到100%。 对我来说，另一个非常重要的好处是，使用TDD编写测试用例很有意思。如果我们反过来，先写生产代码再写测试，相信所有人都会觉得异常痛苦。","categories":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.coding.me/categories/TDD/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.coding.me/tags/TDD/"},{"name":"XP","slug":"XP","permalink":"http://seanyinx.coding.me/tags/XP/"},{"name":"Testing","slug":"Testing","permalink":"http://seanyinx.coding.me/tags/Testing/"}]},{"title":"Stats Calculator with TDD Part 1","slug":"Stats-Calculator-with-TDD-Part-1","date":"2016-12-19T15:19:42.000Z","updated":"2016-12-31T11:44:59.565Z","comments":true,"path":"2016/12/19/Stats-Calculator-with-TDD-Part-1/","link":"","permalink":"http://seanyinx.coding.me/2016/12/19/Stats-Calculator-with-TDD-Part-1/","excerpt":"下面我们来一起通过TDD完成Stats Calculator。在开始前，我们先来看看Robert Martin的three laws of TDD： You can’t write any production code until you have first written a failing unit test. (不能在写完一个失败的测试前，编写任何生产代码) You can’t write more of a unit test than is sufficient to fail, and not compiling is failing. (不能编程超过一个失败的测试，不能编译也算失败) You can’t write more production code than is sufficient to pass the currently failing unit test. (只能编写足够通过当前失败测试的生产代码) 这些法则读起来可能有些不自然，希望我们通过这次练习能更好理解其意义。","text":"下面我们来一起通过TDD完成Stats Calculator。在开始前，我们先来看看Robert Martin的three laws of TDD： You can’t write any production code until you have first written a failing unit test. (不能在写完一个失败的测试前，编写任何生产代码) You can’t write more of a unit test than is sufficient to fail, and not compiling is failing. (不能编程超过一个失败的测试，不能编译也算失败) You can’t write more production code than is sufficient to pass the currently failing unit test. (只能编写足够通过当前失败测试的生产代码) 这些法则读起来可能有些不自然，希望我们通过这次练习能更好理解其意义。 Stats Calculator这道练习题的细节可以在这个链接查看: Calc Stats.12345678910111213141516Calc Stats:Your task is to process a sequence of integer numbersto determine the following statistics:o) minimum valueo) maximum valueo) number of elements in the sequenceo) average valueFor example: 6, 9, 15, -2, 92, 11o) minimum value = -2o) maximum value = 92o) number of elements in the sequence = 6o) average value = 18.166666 让我们先从获取最小值开始。 1. 编写第一个失败的测试用例因为我们此时没有任何生产代码作基础，建议大家在使用TDD编写第一个测试时，从最简单的用例开始，这个用例的场景可以只覆盖需求的部分内容。这里最简单的场景是从一个元素的数列里获取最小值。 在写完测试后，一定要运行测试，以保证测试有效。 2. 让测试通过此时我们的目标是让上一步的测试通过，我们可能这时有一个大概的思路或设计，但不要一次把整个设计付诸于编码，因为此时的设计未必好。 敏捷开发里很重要的一个实践是Simple Design。最好的方式是通过编写最少代码满足测试，让设计逐渐演为最终方案，这样的方案完全以满足当前需求为目的，可能比之前想象的要简单很多。 3. 编写更普适的用例 4. 满足普适的需求 5. 编写边界用例现在正常逻辑路径已经完善，但如果传入的数列为空，则会导致异常。此时比较好的做法是提供足够的异常信息，这样在集成测试或上线以后发现问题时，才能尽快定位问题的根源。 6. 处理边界场景 总结现在我们对TDD的实施有个初步了解，知道如何满足需求的同时，演进设计。最重要的我们知道如何从最简单的测试用例开始，逐步改进我们的代码设计。 这里我们只完成了从数列中查找最小值，下一次我们接着完成剩下的需求。","categories":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.coding.me/categories/TDD/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.coding.me/tags/TDD/"},{"name":"XP","slug":"XP","permalink":"http://seanyinx.coding.me/tags/XP/"},{"name":"Testing","slug":"Testing","permalink":"http://seanyinx.coding.me/tags/Testing/"}]},{"title":"测试驱动开发简介","slug":"Test-Driven-Development-Introduction","date":"2016-12-18T03:29:15.000Z","updated":"2016-12-31T11:44:59.587Z","comments":true,"path":"2016/12/18/Test-Driven-Development-Introduction/","link":"","permalink":"http://seanyinx.coding.me/2016/12/18/Test-Driven-Development-Introduction/","excerpt":"Test Driven Development (测试驱动开发/TDD) 由Kent Beck发扬光大的极限编程实践之一。TDD提倡通过极短重复的开发循环, 演进代码设计，并达到满足需求目的。","text":"Test Driven Development (测试驱动开发/TDD) 由Kent Beck发扬光大的极限编程实践之一。TDD提倡通过极短重复的开发循环, 演进代码设计，并达到满足需求目的。 测试驱动开发的准则TDD的准则有3个步骤：red/green/refactor： 在编写任何生产代码前，编写最简单的失败的测试用例 (red)。 编写最少的生产代码以通过上一步的失败测试 (green) 重构测试用例或生产代码 (Refactor) 测试驱动开发的优点更优的设计众所周知，紧耦合的代码难以测试。既然我们在实施TDD时总是先写测试再完成生产代码，那么我们的代码总是可测的。这意味着通过TDD的方式，较难写出紧耦合的代码。 更少的debug花费实施TDD时，我们总是以极短的red/green/refactor循环编写代码。如果中途某一步出现漏洞，那离上一次测试通过并不久，出现漏洞的代码范围有限，很容易定位问题，很少出现需要花费大量时间debug的情况。 消除破坏既有代码行为的恐惧通过TDD的方式编写的代码通常有很高的测试覆盖率 (90%以上很容易实现)，因为在写生产代码前总会先写测试。在这样的高代码覆盖率下，因为疏忽而破坏既有代码行为的可能性是比较低的。 持续改善代码质量在消除破坏代码行为的恐惧后，我们更有可能通过重构来改善我们的代码质量。不然，我们会担心重构导致漏洞，而给自己增加不必要的麻烦。 测试用例作为文档修改代码时，我们必定更新测试用例，但我们未必会同时更新文档，事实上很多时候文档都是过时的。高质量的测试用例是最好形式的文档，因为他们永不过时，而且对代码应用场景的描述最精确。 如何开始实施?测试驱动开发简单易懂，却难以精通。提高我们TDD技能的最好方式是通过不断的练习。网上有很多这样名为Kata的练习题，通过这些题我们可以更快的掌握TDD的技巧。下一篇文章里，我们用最简单的Kata，Calc Stats 来练习使用TDD的方式编程。","categories":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.coding.me/categories/TDD/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.coding.me/tags/TDD/"},{"name":"XP","slug":"XP","permalink":"http://seanyinx.coding.me/tags/XP/"},{"name":"Testing","slug":"Testing","permalink":"http://seanyinx.coding.me/tags/Testing/"}]},{"title":"Hello World","slug":"Hello-World","date":"2016-12-18T03:26:00.000Z","updated":"2016-12-22T13:48:12.197Z","comments":true,"path":"2016/12/18/Hello-World/","link":"","permalink":"http://seanyinx.coding.me/2016/12/18/Hello-World/","excerpt":"","text":"","categories":[],"tags":[]}]}