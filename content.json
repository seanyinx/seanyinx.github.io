{"meta":{"title":"Agile","subtitle":null,"description":null,"author":"Sean Yin","url":"http://seanyinx.github.io"},"pages":[{"title":"Categories","date":"2016-12-18T03:34:19.000Z","updated":"2016-12-18T03:34:19.414Z","comments":true,"path":"Categories/index.html","permalink":"http://seanyinx.github.io/Categories/index.html","excerpt":"","text":""},{"title":"About","date":"2016-12-18T03:20:49.000Z","updated":"2016-12-18T03:20:49.981Z","comments":true,"path":"About/index.html","permalink":"http://seanyinx.github.io/About/index.html","excerpt":"","text":""}],"posts":[{"title":"Stats Calculator with TDD Part 1","slug":"Stats-Calculator-with-TDD-Part-1","date":"2016-12-19T15:19:42.000Z","updated":"2016-12-21T12:45:08.066Z","comments":true,"path":"2016/12/19/Stats-Calculator-with-TDD-Part-1/","link":"","permalink":"http://seanyinx.github.io/2016/12/19/Stats-Calculator-with-TDD-Part-1/","excerpt":"I am going to demonstrate how to complete Stats Calculator with Test Driven Development.Before we start, let me introduce you the three laws of TDD by Robert Martin. You can’t write any production code until you have first written a failing unit test. You can’t write more of a unit test than is sufficient to fail, and not compiling is failing. You can’t write more production code than is sufficient to pass the currently failing unit test. It reads unnatural at first, but I hope you will understand better after reading this post.","text":"I am going to demonstrate how to complete Stats Calculator with Test Driven Development.Before we start, let me introduce you the three laws of TDD by Robert Martin. You can’t write any production code until you have first written a failing unit test. You can’t write more of a unit test than is sufficient to fail, and not compiling is failing. You can’t write more production code than is sufficient to pass the currently failing unit test. It reads unnatural at first, but I hope you will understand better after reading this post. Stats CalculatorThe details of this kata can be found in the link: Calc Stats.12345678910111213141516Calc Stats:Your task is to process a sequence of integer numbersto determine the following statistics:o) minimum valueo) maximum valueo) number of elements in the sequenceo) average valueFor example: 6, 9, 15, -2, 92, 11o) minimum value = -2o) maximum value = 92o) number of elements in the sequence = 6o) average value = 18.166666 Let’s start with finding the minimum value. 1. Write the 1st Failing TestIt’s recommended to write the 1st failing test as simple as possible and only partially cover the requirement, since we have no production code to start with. In our case, the simplest case is to find the minimum from a single element. Make sure you run the failing test case before proceeding with production code, in order to make sure it is effective. 2. Make the Test PassAt this moment, our goal is just to make the 1st test case pass. We may have a rough design concept in mind, but we do not just put the entire design to code, since we are not sure if it’s a good one. One of the most important practices in Agile is Simple Design. It’s better to evolve our code gradually by writing the minimum code that make the test cases pass. Let the final solution emerge. 3. Write a More General Failing TestNow we can expand our tests to cover more general cases. 4. Satisfy The Requirement 5. Write a Boundary Test CaseThe happy path works fine now, but we have to take care of the boundary case, an empty sequence of integers. There’s nothing much we can do except throwing an exception to tell the caller that something is wrong in this case. By the way, it’s a good practice to make sure the exception message is meaningful too, so that the issue can be easily identified in integration tests or logs in production by our support. 6. Implement the Boundary Case SummaryNow we have seen how we can use TDD to not only fulfill the requirement, but also evolve our solution to a good design. A very important lesson here is to start with the simplest test case possible, and gradually improve our code to a better design. It’s very easy to get stuck trying to come up with a perfect solution in the first place. We only completed finding the minimum of a sequence of integers today. Next, we will proceed with the rest of the requirements.","categories":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.github.io/categories/TDD/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.github.io/tags/TDD/"},{"name":"XP","slug":"XP","permalink":"http://seanyinx.github.io/tags/XP/"},{"name":"Testing","slug":"Testing","permalink":"http://seanyinx.github.io/tags/Testing/"}]},{"title":"Test Driven Development Introduction","slug":"Test-Driven-Development-Introduction","date":"2016-12-18T03:29:15.000Z","updated":"2016-12-21T13:17:37.037Z","comments":true,"path":"2016/12/18/Test-Driven-Development-Introduction/","link":"","permalink":"http://seanyinx.github.io/2016/12/18/Test-Driven-Development-Introduction/","excerpt":"Test Driven Development (TDD) is one of the eXtreme Programming (XP) practices developed by Kent Beck.It promotes repetitions of short coding cycles, to evolve the solutions with new requirements.","text":"Test Driven Development (TDD) is one of the eXtreme Programming (XP) practices developed by Kent Beck.It promotes repetitions of short coding cycles, to evolve the solutions with new requirements. The Coding Cycle of TDDTDD has a “mantra” with 3 steps, red/green/refactor: Write a simplest failing test case (hence red), before writing any production code. Write minimal production code possible to pass the failing test case (green) Refactor test case or production code The Benefit of TDDBetter designAs we know, tightly coupled code are hard to test. Since we always write tests before any production code, our code are always testable,meaning it is hard to write tightly coupled code with TDD. Much less code debuggingWe are working in short cycles of red/green/refactor with TDD. There won’t be much code written after the previous time our tests passed.That limits the scope of the bug we introduced and makes it very easy to spot. No fear to break codeTDD tends to produce code with very high test coverage (90%+ is very easy to achieve), since tests are always written first.It’s much less likely to break the code accidentally with such high code coverage. Continuous code improvement with refactoringTests are vital to refactoring. We are more likely to improve our code quality with refactoring, because the fear to break code is eliminated with tests.Or, nobody will touch bad code. We are afraid that the bad code will be ours, if we break it. Test case as documentationIf written well, test cases are the best documentation, because they are always up to date and describe the exact scenarios on how to use the production code. How To Start?TDD is an easy-to-learn but hard-to-master skill. The best way to improve our skill on TDD is through practices.There are many exercises called Katas, which can help accelerate our learning process.I will use one of the simplest Kata, Calc Stats to demonstrate how to get started with TDD in my next post.","categories":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.github.io/categories/TDD/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"http://seanyinx.github.io/tags/TDD/"},{"name":"XP","slug":"XP","permalink":"http://seanyinx.github.io/tags/XP/"},{"name":"Testing","slug":"Testing","permalink":"http://seanyinx.github.io/tags/Testing/"}]},{"title":"Hello World","slug":"Hello-World","date":"2016-12-18T03:26:00.000Z","updated":"2016-12-18T03:26:00.180Z","comments":true,"path":"2016/12/18/Hello-World/","link":"","permalink":"http://seanyinx.github.io/2016/12/18/Hello-World/","excerpt":"","text":"","categories":[],"tags":[]}]}